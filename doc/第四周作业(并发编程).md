### **一、 什么是线程和进程**

##### 1 区别

| 区别维度 | 进程                                                         | 线程                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 本质     | 操作系统进行资源分配的基本单位                               | 处理器调度和分派的基本单位                                   |
| 资源     | 每个进程都有独立的内存空间和数据空间，进程之间的切换会有较大开销 | 多线程之间堆空间和方法区共享，但每个线程的栈空间和程序计数器是独立的，线程消耗的资源比进程小的多 |
| 健壮性   | 一个进程崩溃后，在保护模式下不会对其他进程造成影响           | 一个线程崩溃，可能会导致包含该线程的整个进程都直接死掉       |



##### 2 关系

```txt
1、一个线程只能属于一个进程，一个进程可以有多个线程，但至少一个线程。
2、资源分配给进程，同一进程下的线程共享该进程的所有资源。
3、线程是进程中的一个执行单元，负责当前进程中任务的执行。
```

##### 3 线程的上下文切换是什么

```txt
    线程在CPU分配的时间片内执行任务，当时间片用完后线程会被挂起，并将当前线程任务状态保存，下次CPU切回任务时再次加载，这个过程即是线程上下文切换
    上下文切换过程
    1、挂起当前线程任务，保存任务在CPU的状态（上下文），程序计数器记录当前线程执行的位置。
    2、恢复一个任务，在内存中检索下一个任务的上下文并将在CPU的寄存器中恢复。
    3、跳转到程序计数器所指定的位置（即跳转到任务被中断时的代码行）。
```



### 二、多线程会带来什么问题

#### 1、线程安全问题

 **1）什么是线程安全问题**

```txt
	 如果有多个线程在同时运行，而多个线程可能会同时执行同一行代码。如果程序每次运行结果和单线程运行结果一样，且其他变量的值也和预期的值一样，就是线程安全的，反之则是线程不安全。
```

**2）线程安全问题的原因**

```txt
	 在多线程环境中，若线程间存在共享变量，则会引发资源竞争，从而导致线程安全问题。
   如果每个线程中对共享变量只有读操作，而没有写操作，一般来说，这个共享变量是线程安全的。如果有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能造成线程安全问题。
```

**3）如何解决线程安全问题**

```txt
1、线程同步机制。使用synchronize关键字修饰代码块或方法。synchronize基于monitorenter和monitorexit指令来锁定和解锁monitor对象以实现线程同步。
2、volatile关键字，利用内存屏障和禁止指令重排序以实现内存可见性和有序性。这样可保证多线程场景下变量的可见性和有序性，但不能保证原子性。
3、JUC，包括原子类（CAS）和锁（AQS）。CAS即比较并交换，AQS即是队列同步器
```

#### 2、原子性、有序性和可见性

**1）原子性**

```txt
	  原子性即一个操作或多个操作，要么全部执行那么都不执行。执行过程中，不能被中断。比如数据库操作必须全部完成，或者全部不完成。原子具有不可分割性，比如a=0，这个操作是不可分割的，但是a++，实际是a=a+1，是可分割的，所以它不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术如synchronized来让它变成一个原子操作。
	 一个操作是原子操作，那么我们就称它具有原子性。
```

**2）有序性**

```txt
    在JMM中，允许编译器和处理器对指令进行重排序，但重排序过程不会影响单线程程序的执行，却会影响多线程并发执行的结果。通过volatile、synchronized、lock保证有序性。保证有序性需遵循两个原则：
    1、as-if-serial原则：不管怎么重排序，单线程程序的执行结果不能被改变
    2、happens-before原则
    		1）程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先于书写在后面的操作
    		2）锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作，也就是说只有先解锁才能对下面的线程进行加锁。
    		3）volatile变量原则：对一个变量的写操作先行发生于后面的读操作
    		4）传递原则：如果操作A先行发生于操作B，而操作B先行发生于操作C，则操作A先行发生于操作C
```

##### 3）可见性

```txt
    所谓可见性即是当多个线程访问同一变量时，当其中一个线程修改了这个变量的值，其他线程能够立即看到修改的值。
    导致共享变量在多线程间不可见的原因：
    1、线程交叉执行
    2、重排序结合线程交叉执行
    3、共享变量更新后的值没有在工作内存中与主内存间及时更新
    volatile、synchronized、lock可保证可见性。其中JMM对synchronized有两条规定即线程解锁前，必须把共享变量的最新值刷新到主内存中。线程加锁时，将清空工作内存中共享变量的值，从而使得在使用共享变量时需要从主内存中重新读取最新的值。
    而volatile则通过内存屏障和禁止重排序优化来实现可见性，具体实现如下：
    1、对volatile变量写操作时，会在写操作后加入一条store屏障指令，将本地内存中的共享变量值刷新到主内存
    2、对volatile变量读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量
```



### 三、**什么是死锁？如何排查死锁**

#### 1、什么是死锁

```txt
     java线程死锁是一个经典的多线程问题，因为不同的线程都在等待根本不可能被释放的锁，从而导致所有的任务都无法继续完成。
     造成死锁的4个必要条件：
     1、互斥条件：当资源被一个线程使用（占有）时，其他线程不能使用
     2、请求保持条件：当资源请求者在请求其他资源的同时保持对原有资源的占有。一个线程去尝试获取多把锁，在获取第二把锁的过程中，保持对第一把锁的获取状态
     3、不可剥夺条件：资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。
     4、环路条件（循环等待）：即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源，这样就形成了一个等待环路。
```



#### 2、如何排查死锁

```txt
	JDK中自带的Jstack工具是一个线程堆栈分析工具，可以帮助我们排查java程序中是否有死锁问题
	1）通过命令 jps 查看当前正在执行任务的PID
	2）确认进程ID，然后使用jstack工具查看当前进程的堆栈信息，分析查找造成可能造成死锁的原因
```

